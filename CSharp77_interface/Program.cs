using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//https://www.youtube.com/watch?v=8eZy5xiildM
/*Интерфейсы
 * 
 * Интерфейсы можно сравнить с абстрактным классом у которого только абстрактные методы, то есть вооюще нет никакой реализации
 * 
 * С помощью интерфейса мы определяем поведение, которое в последсвии будет реализована в каком-то конкретном классе
 * 
 * Важное отличие от класса в том что интерфейсы позволяют множественное наследование, они могут наследоваться между собой,
 * причем 1 интерфейс может унаследовать несколько разных, так и 1 определенный класс может унаследовать несколько интерфейсов
 * 
 * !!!Когда мы говорим о том что класс унаследован от интерфейса, то правильно говорить что класс реализует интерфейс!!!
 * 
 * Интерфейс это не класс и в нем не может быть конструкторов, в отличие от абстрактного класса в котором конструкторы могут быть
 * 
 * Экземпляр интерфейса как и экземпляр абстрактного класса мы создать не можем
 * 
 * Интерфейс не может содержать поля класса, так как интерфейсы должны определять поведения и контракт, но не должны содержать какойто конкретной реализации
 * 
 * В интерфейсе мы определяем поведение. В ООП поведение определяется с помощью методов.
 * На самом деле интерфейсы не ограничиваются только методами.
 * 
 * Важное отличие интерфейса заключается в том что по умолчанию все члены интерфейса имеют модификатор public
 * соответсвенно указывать модификатор доступа не нужно, он по умолчанию public
 * 
 * То что мы можем создать переменную у которой тип данных это тип интерфейса это очень важный момент 
 * это позволяет использовать полеморфизм как и в случае с абстрактными классами так и в случае с наследованием
 * 
 * Точно так же как ссылка базового класса может хранить объекты наследников, ссылка интерфейса может хранить в себе обьект любого класса который реализовывает данный интерфейс
 * 
 * Если мы указываем что хотим реализовать в каком то классе интерфейс, то мы должны реализовать все компоненты интерфейса в обязателном порядке
 */
namespace CSharp77_interface
{
    /// <summary>
    /// Определяет контракт для класса, который будет получать данные откудо-то
    /// </summary>
    interface IDataProvider
    {
        //получаем данные в виде строки
        //по сути мы просто описали сигнатуру метода, который будет реализован в классе, который будет реализовывать данный интерфейс
        //это нечто схожее с абстрактным методом в абстрактном классе,
        //но важное отличие интерфейса заключается в том что по умолчанию все члены интерфейса имеют модификатор public
        /// <summary>
        /// получаем данные в виде строки
        /// </summary>
        /// <returns></returns>
        string GetData();
    }

    /// <summary>
    /// Интерфейс для обработки данных
    /// </summary>
    interface IDataProcessor
    {
        //В классе который быдет реализовывать этот интерфейс
        //должен присутсвовать метод ProcessData который в качестве параметра будет принимать обьект класса который будеть реализовывать интерфейс IDataProvider
        void ProcessData(IDataProvider dataProvider);
    }

    /// <summary>
    /// класс реализующий интерфейс IDataProcessor
    /// </summary>
    class ConsoleDataProcessor : IDataProcessor
    {
        public void ProcessData(IDataProvider dataProvider)
        {
            Console.WriteLine(dataProvider.GetData());
        }
    }

    class DbDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из БД";
        }
    }

    class FileDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из файла";
        }
    }

    class APIDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из API";
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            IDataProcessor dataProcessor = new ConsoleDataProcessor();
            //dataProcessor можетработать с чем угодно, лишь бы это что угодно реализовывала интрефейс IDataProvider и соответсвенно в нем в любом случае был метод GetData
            //чтобы конкретный процессор который мы реализовываем который реализовывает интерфейс IDataProcessor мог у этого dataProvider вызвать этот самый метот GetData

            dataProcessor.ProcessData(new DbDataProvider());
            dataProcessor.ProcessData(new FileDataProvider());
            dataProcessor.ProcessData(new APIDataProvider());
        }
    }
}
